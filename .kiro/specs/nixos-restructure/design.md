# NixOS Configuration Restructure Design

## Overview

This design transforms a monolithic NixOS configuration into a modular, multi-host architecture. The restructured system will separate concerns into logical modules, support multiple hosts with shared configurations, and maintain clear boundaries between system and user settings.

## Architecture

The new architecture follows a hierarchical structure:

```
/etc/nixos/
├── flake.nix                 # Main flake with host definitions
├── hosts/                    # Host-specific configurations
│   ├── thonkpad/            # Current host (renamed from nixos)
│   │   ├── configuration.nix
│   │   ├── hardware.nix
│   │   └── users.nix
│   └── [future-hosts]/      # Additional hosts as needed
├── modules/                  # Reusable system modules
│   ├── desktop/             # Desktop environment modules
│   ├── development/         # Development tools and environments
│   ├── networking/          # Network configurations
│   ├── security/            # Security and authentication
│   └── services/            # System services
├── profiles/                # Pre-configured system profiles
│   ├── desktop.nix          # Desktop workstation profile
│   ├── server.nix           # Server profile
│   └── minimal.nix          # Minimal system profile
├── users/                   # User-specific configurations
│   ├── jacob/               # Per-user directory
│   │   ├── home.nix
│   │   └── packages.nix
│   └── templates/           # User configuration templates
└── lib/                     # Helper functions and utilities
    └── default.nix
```

## Components and Interfaces

### Host Configuration
Each host will have its own directory containing:
- `configuration.nix`: Host-specific system settings (hostname, timezone, etc.)
- `hardware.nix`: Hardware-specific configuration (generated by nixos-generate-config)
- `users.nix`: Host-specific user definitions and assignments

### Modules
Modules are organized by functionality:
- **Desktop Modules**: Window managers, display managers, themes
- **Development Modules**: Programming languages, tools, IDEs
- **Networking Modules**: WiFi, VPN, firewall configurations
- **Security Modules**: Authentication, encryption, access control
- **Services Modules**: System services like Docker, SSH, printing

### Profiles
Profiles combine multiple modules for common use cases:
- **Desktop Profile**: Complete desktop workstation setup
- **Server Profile**: Headless server configuration
- **Minimal Profile**: Basic system with essential tools only

### User Management
User configurations are separated from system configuration:
- Each user has their own directory under `users/`
- Home Manager configurations are user-specific
- User package lists are maintained separately from system packages

## Data Models

### Host Definition
```nix
{
  hostname = "string";
  profile = "desktop" | "server" | "minimal";
  hardware = ./path/to/hardware.nix;
  users = [ "username1" "username2" ];
  extraModules = [ ./custom/module.nix ];
  system = "x86_64-linux" | "aarch64-linux";
}
```

### Module Structure
```nix
{ config, lib, pkgs, ... }:
{
  options = {
    # Module-specific options
  };
  
  config = lib.mkIf config.modules.moduleName.enable {
    # Module configuration
  };
}
```

### User Configuration
```nix
{
  username = "string";
  homeDirectory = "/home/username";
  packages = [ /* user-specific packages */ ];
  dotfiles = {
    # User dotfile configurations
  };
  services = {
    # User-specific services
  };
}
```

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Property Reflection

After analyzing all acceptance criteria, several properties can be consolidated to eliminate redundancy:

- Properties about configuration preservation (5.1, 5.2, 5.3, 5.4, 5.5) can be combined into comprehensive equivalence properties
- Properties about proper organization (1.1, 1.2, 4.1, 4.3, 4.5) can be consolidated into structural validation properties
- Properties about module inheritance (2.2, 2.5) can be combined into a single module reuse property

### Core Properties

**Property 1: Configuration Structural Integrity**
*For any* restructured NixOS configuration, all hardware-specific settings should only appear in designated hardware configuration files, and all module files should contain only functionality related to their declared purpose
**Validates: Requirements 1.1, 1.2, 4.3, 4.5**

**Property 2: Functional Equivalence After Restructuring**
*For any* system configuration, the restructured system should produce identical functionality, installed packages, enabled services, and user settings compared to the original monolithic configuration
**Validates: Requirements 1.3, 5.1, 5.2, 5.3, 5.4, 5.5**

**Property 3: Module Change Propagation**
*For any* shared module modification, all hosts that import that module should reflect the changes in their final configuration
**Validates: Requirements 1.4**

**Property 4: Profile-Based Configuration Differentiation**
*For any* two different system profiles (desktop vs server), they should produce meaningfully different system configurations appropriate to their intended use case
**Validates: Requirements 1.5**

**Property 5: Minimal Host Definition Requirements**
*For any* new host addition, only hostname, hardware configuration, and user assignments should be required, with all other configuration inherited from profiles and modules
**Validates: Requirements 2.1, 2.2**

**Property 6: Build System Validation**
*For any* host configuration with missing required modules, the build process should fail with clear error messages indicating the missing dependencies
**Validates: Requirements 2.3**

**Property 7: Independent Host Building**
*For any* multi-host configuration, building one host should not affect the configuration or build status of other hosts
**Validates: Requirements 2.4**

**Property 8: Module Reuse Without Duplication**
*For any* functionality shared between multiple hosts, the implementation should exist in exactly one module location and be imported by all hosts that need it
**Validates: Requirements 2.5**

**Property 9: User-System Configuration Separation**
*For any* user-specific setting, it should only appear in user configuration files and never in system-wide configuration files
**Validates: Requirements 3.1, 3.3**

**Property 10: Per-User Home Manager Independence**
*For any* multiple-user system, each user should have independent Home Manager configurations that can be modified without affecting other users
**Validates: Requirements 3.2**

**Property 11: User Template System**
*For any* new user creation, appropriate template configurations should be available and applicable based on user role
**Validates: Requirements 3.4, 3.5**

**Property 12: Directory Structure Compliance**
*For any* configuration file in the restructured system, it should be located in a directory that logically corresponds to its functionality according to the defined hierarchy
**Validates: Requirements 4.1**

**Property 13: Consistent Naming Convention**
*For any* configuration file, its name should follow consistent patterns that clearly indicate its purpose and functionality
**Validates: Requirements 4.2**

## Error Handling

The restructured configuration will implement comprehensive error handling:

### Build-Time Validation
- **Missing Module Detection**: Validate all module imports exist before building
- **Circular Dependency Detection**: Prevent modules from creating circular import chains
- **Hardware Configuration Validation**: Ensure hardware configs are properly formatted and complete
- **User Configuration Validation**: Verify user configurations reference valid users and settings

### Runtime Error Recovery
- **Fallback Configurations**: Provide minimal fallback configs if modules fail to load
- **Graceful Degradation**: Allow system to boot with reduced functionality if non-critical modules fail
- **Configuration Rollback**: Enable easy rollback to previous working configurations
- **Detailed Error Logging**: Provide clear error messages with actionable remediation steps

### Validation Checks
- **Profile Completeness**: Ensure profiles include all necessary modules for their intended use case
- **Module Interface Compliance**: Validate modules implement required interfaces correctly
- **Host Configuration Completeness**: Verify hosts define all required settings
- **User Permission Validation**: Ensure user configurations don't request invalid permissions

## Testing Strategy

The restructuring will employ a dual testing approach combining unit tests and property-based tests to ensure correctness and maintainability.

### Unit Testing Approach
Unit tests will verify specific examples and integration points:
- **Configuration Parsing**: Test that individual configuration files parse correctly
- **Module Loading**: Verify modules load and initialize properly
- **Profile Application**: Test that profiles apply expected configurations
- **User Template Application**: Verify user templates create correct configurations
- **Error Condition Handling**: Test specific error scenarios and recovery mechanisms

### Property-Based Testing Approach
Property-based tests will verify universal properties across all inputs using **Nix's built-in testing framework** and custom validation scripts. Each property-based test will run a minimum of **100 iterations** to ensure comprehensive coverage.

**Property-based testing requirements:**
- Each correctness property will be implemented by a single property-based test
- Tests will be tagged with comments referencing the design document property: `**Feature: nixos-restructure, Property {number}: {property_text}**`
- Tests will generate random but valid configuration variations to verify properties hold universally
- Custom generators will create realistic NixOS configuration scenarios for testing

**Test Coverage Strategy:**
- **Configuration Generation**: Generate various host, module, and user configuration combinations
- **Structural Validation**: Verify directory structures and file organizations meet requirements
- **Functional Equivalence**: Compare system outputs before and after restructuring
- **Module Interaction**: Test various combinations of modules and profiles
- **Error Injection**: Introduce configuration errors to verify proper error handling

**Integration Testing:**
- **End-to-End Build Tests**: Verify complete configurations build successfully
- **Multi-Host Scenarios**: Test configurations with multiple hosts and shared modules
- **Migration Testing**: Verify smooth transition from monolithic to modular structure
- **Rollback Testing**: Ensure configurations can be safely reverted if needed

The testing strategy ensures both specific functionality works correctly (unit tests) and general correctness properties hold across all possible configurations (property-based tests).